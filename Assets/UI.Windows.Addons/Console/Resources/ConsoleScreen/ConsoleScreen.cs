//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the UI.Windows Flow Addon.
//     You may simply edit this file to setup your behavior.
//     See more: https://github.com/chromealex/Unity3d.UI.Windows
// </auto-generated>
//------------------------------------------------------------------------------

using UnityEngine.UI.Windows.Components;
using UnityEngine.Events;
using System.Collections.Generic;
using System.Collections;
using UnityEngine.UI.Windows.Plugins.Console.Components;

namespace UnityEngine.UI.Windows.Plugins.Console {

	public class ConsoleScreen : ConsoleScreenBase {

		//public const int MAX_LINES_LIMIT = 100;

		[System.NonSerialized]
		public TextComponent alwaysShownText;

		private System.Action<string> onCommand;
		private System.Func<string, bool> onCommandCheck;

		private InputFieldComponent commandLine;
		//private TextComponent commandQueue;
		private ConsoleViewComponent commandQueue;
		private WindowLayoutElement queueContainer;
		
		private List<string> all;
		private int selectionIndex = -1;

		private List<string> queue;

		private WindowLayoutElement container;
		private bool lockEvents = false;

		private DecoratorComponent exceptionBorder;

		public float clearTime = -1f;
		public float heightPadding = 8f;

		public override void OnInit() {

			base.OnInit();

			this.all = ME.ListPool<string>.Get();
			this.queue = ME.ListPool<string>.Get();

			this.GetLayoutComponent(out this.exceptionBorder, LayoutTag.Tag6);
			this.GetLayoutComponent(out this.alwaysShownText, LayoutTag.Tag4);

			this.GetLayoutComponent(out this.commandQueue);
			this.commandQueue.SetScreen(this);

			this.queueContainer = this.GetLayoutContainer(LayoutTag.Tag3);

			this.GetLayoutComponent(out this.commandLine);
			this.commandLine.SetCallbacks(null, (text) => {
				
				this.AddLineCmd(text);

			});

			this.container = this.GetLayoutContainer(LayoutTag.Tag1);

			this.HideExceptionBorder();
			Application.logMessageReceived += this.OnMessage;

		}

		public override void OnDeinit(System.Action callback) {

			base.OnDeinit(callback);

			ME.ListPool<string>.Release(this.all);
			ME.ListPool<string>.Release(this.queue);
			this.all = null;
			this.queue = null;

		}

		public string GetInputText() {

			return this.commandLine.GetText();

		}

		public void HideExceptionBorder() {

			this.exceptionBorder.Hide();

		}

		private void OnMessage(string condition, string stackTrace, LogType type) {

			if (type == LogType.Exception) {

				this.exceptionBorder.Show();

			}

		}

		public void LateUpdate() {

			if (Application.isPlaying == false) return;

			if (this.container.GetComponentState() == WindowObjectState.Shown) {

				if (this.commandLine.HasFocus() == false) {

					this.Focus();

				}

			}

		}

		public bool IsReusable(int row) {

			return this.all.Contains(this.queue[row]);

		}

		public string GetQueueText(int row) {

			return this.queue[row];

		}

		public float GetQueueLineHeight(int row) {

			return (this.commandQueue.source as ConsoleCellComponent).buttonComponent.GetContentHeight(this.GetQueueText(row), (this.queueContainer.transform as RectTransform).rect.size) + this.heightPadding;

		}

		public int GetQueueCount() {

			return this.queue.Count;

		}

		public void MovePrev() {
			
			++this.selectionIndex;
			if (this.selectionIndex < this.all.Count && this.selectionIndex >= 0) {
				
				this.Move();

			} else {
				
				--this.selectionIndex;
				
			}
			
		}
		
		public void MoveNext() {
			
			--this.selectionIndex;
			if (this.selectionIndex < this.all.Count && this.selectionIndex >= 0) {

				this.Move();

			} else {
				
				++this.selectionIndex;
				
			}
			
		}

		private void Move() {

			var text = this.all[this.all.Count - 1 - this.selectionIndex];
			this.SetInputText(text);

		}

		public void SetInputText(string text) {
			
			this.lockEvents = true;

			this.commandLine.SetText(text);
			this.Focus();
			
			this.lockEvents = false;

		}

		public void ShowConsole() {

			this.container.Show();
			this.Clear();
			this.Focus();

			WindowSystem.AddToHistory(this.GetWindow(), WindowObjectState.Shown, forced: true);

		}

		public void HideConsole() {

			this.container.Hide();
			
			WindowSystem.RemoveFromHistory(this.GetWindow());

		}

		public void MoveCaretTo(int position) {
			
			this.commandLine.SetCaretPosition(position);
			
		}
		public void MoveCaretToEnd() {
			
			this.commandLine.MoveCaretToEnd();
			
		}

		public void Focus() {

			this.commandLine.SetFocus();

		}

		public void Clear() {

			this.commandLine.SetText(string.Empty);
			this.selectionIndex = -1;

		}

		public void ClearQueue() {

			this.queue.Clear();
			this.UpdateQueue();

		}
		
		public void ReplaceLastLine(string text) {

			this.queue.RemoveAt(this.queue.Count - 1);
			this.queue.Add(text);

			this.UpdateQueue();

		}

		public void AddLine(string text, params object[] pars) {

			var reuseable = false;

			this.AddLine(string.Format(text, pars), reuseable);

		}

		public void AddLine(string text, bool reuseable = false) {

			if (reuseable == false) {

				text = string.Format("<color=#fff>{0}</color>", text);

			}

			/*if (this.queue.Count > ConsoleScreen.MAX_LINES_LIMIT) {

				this.queue.RemoveAt(0);

			}*/

			this.queue.Add(text);
			if (reuseable == true) this.all.Add(text);
			this.commandQueue.Add();

			this.UpdateQueue();

			if (this.clearTime > 0f) this.StartCoroutine(this.RemoveFirst());

		}

		private int lastFrame;
		public void AddLineCmd(string text) {

			if (this.lockEvents == true) return;
			if (string.IsNullOrEmpty(text) == true) return;
			if (this.lastFrame == Time.frameCount) return;
			
			this.Focus();

			if (this.onCommandCheck(text) == false) return;
			
			this.Clear();
			this.Focus();

			this.AddLine(text, reuseable: true);
			this.onCommand.Invoke(text);

			this.lastFrame = Time.frameCount;

		}

		private System.Collections.IEnumerator RemoveFirst() {

			if (this.clearTime <= 0f) yield break;

			yield return new WaitForSeconds(this.clearTime);

			if (this.queue.Count > 0) {

				this.queue.RemoveAt(0);
				this.UpdateQueue();

			}

		}

		public void UpdateQueue() {

			/*var text = string.Empty;
			foreach (var line in this.queue) {
				
				text += line + "\n";
				
			}

			this.commandQueue.SetText(text);*/

			this.commandQueue.UpdateQueue();

		}

		public void Register(System.Action<string> onCommand, System.Func<string, bool> onCommandCheck) {
			
			this.onCommand = onCommand;
			this.onCommandCheck = onCommandCheck;

		}

	}

}